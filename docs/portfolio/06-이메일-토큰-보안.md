# 이메일 인증 토큰 보안 강화 회고

> 2025년 10월, DB 유출 시나리오를 고려한 리팩토링

## 개요

- **문제 발견**: 2025년 10월 (보안 감사 중)
- **해결 완료**: 2025년 10월 (반나절 소요)
- **개선**: 평문 토큰 → SHA-256 해싱 + Constant-time 비교

---

## 문제 발견

코드 리뷰 중 이 부분을 발견했다.

```python
# backend/accounts/models.py (초기 버전)
class User(AbstractUser):
    email_verification_token = models.CharField(max_length=64)

    def generate_email_verification_token(self):
        token = get_random_string(64)
        self.email_verification_token = token  # 평문 그대로 저장
        return token
```

데이터베이스를 확인했다:

```sql
SELECT email, email_verification_token FROM accounts_user LIMIT 3;
```

| email | email_verification_token |
|-------|-------------------------|
| user1@example.com | aB3dF9kL2mN5pQ7r... (평문) |
| user2@example.com | zY9xW8vU7tS6rQ5p... (평문) |

**토큰이 그대로 보였다.**

---

## 보안 위협 시나리오

### 시나리오 1: DB 유출

```
해커가 DB 백업 파일 획득
    ↓
email_verification_token 테이블 조회
    ↓
토큰으로 /verify-email?token=... 접속
    ↓
계정 탈취 완료
```

### 시나리오 2: Timing Attack

기존 코드는 일반 문자열 비교를 썼다:

```python
def verify_email(self, token):
    return self.email_verification_token == token  # 취약
```

Python의 `==` 연산자는 **순차 비교**한다.
틀린 문자를 만나면 즉시 종료하므로, 응답 시간으로 토큰을 한 글자씩 추측할 수 있다.

```
"ABC123" vs "XYZ789" → 0.001ms (첫 글자부터 틀림)
"ABC123" vs "ABZ789" → 0.003ms (3번째 문자에서 틀림)
"ABC123" vs "ABC789" → 0.004ms (4번째 문자에서 틀림)
```

---

## 해결 과정

### 1단계: SHA-256 해싱 도입

**핵심 아이디어**: DB에는 해시만 저장, 원본 토큰은 이메일로만 전송

```python
# backend/accounts/models.py:107
import hashlib
import secrets

def generate_email_verification_token(self):
    """토큰 생성 및 해시 저장

    나중에 볼 나를 위한 메모:
    - secrets 모듈로 안전한 랜덤 생성
    - SHA-256으로 해싱 후 DB 저장
    - 원본 토큰은 반환만 (이메일로 전송됨)
    """
    # 1. 32바이트 랜덤 토큰 생성
    token = secrets.token_urlsafe(32)

    # 2. SHA-256 해싱
    token_hash = hashlib.sha256(token.encode()).hexdigest()

    # 3. 해시만 DB에 저장
    self.email_verification_token = token_hash
    self.email_verification_sent_at = timezone.now()
    self.save()

    # 4. 원본 토큰 반환 (이메일로 전송)
    return token
```

이제 DB에는 이렇게 저장된다:

```sql
SELECT email, email_verification_token FROM accounts_user LIMIT 1;
```

| email | email_verification_token |
|-------|-------------------------|
| user@example.com | 2cf24dba5fb0a30e26e83b2ac5b9e29e... (SHA-256 해시) |

**원본 토큰을 알 수 없다.**

### 2단계: Constant-time 비교

```python
# backend/accounts/models.py:125
def verify_email(self, token):
    """토큰 검증 (Timing Attack 방어)

    나중에 또 까먹을까봐 주석 자세히 씀
    """
    if not self.email_verification_token:
        return False

    # 1. 입력받은 토큰을 해싱
    token_hash = hashlib.sha256(token.encode()).hexdigest()

    # 2. Constant-time 비교 (핵심)
    if not secrets.compare_digest(self.email_verification_token, token_hash):
        return False

    # 3. 만료 시간 확인
    if self.email_verification_sent_at:
        expiry = self.email_verification_sent_at + timedelta(days=1)
        if timezone.now() > expiry:
            return False

    # 4. 검증 성공 → 일회용 토큰 삭제
    self.is_email_verified = True
    self.email_verification_token = None
    self.save()

    return True
```

### 왜 secrets.compare_digest()를 쓸까?

```python
# 일반 비교: 틀린 문자 발견 시 즉시 종료
a == b  # Timing attack 취약

# Constant-time 비교: 항상 모든 문자 비교
secrets.compare_digest(a, b)  # 안전
```

---

## 핵심 개념 설명

### secrets.token_urlsafe()

```python
import secrets

# 안전하지 않음
import random
token = ''.join(random.choices(string.ascii_letters, k=32))

# 암호학적으로 안전
token = secrets.token_urlsafe(32)  # OS의 난수 생성기 사용
```

### hashlib.sha256()

```python
import hashlib

hashlib.sha256('hello'.encode()).hexdigest()
# → '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'

hashlib.sha256('hella'.encode()).hexdigest()  # 한 글자만 다름
# → '3f8e1e8c99ab4d5ed58e6e0d5c82b5e3a9c8e6f4c7b5d3a9c8e6f4c7b5d3a9c8'
# 완전히 다른 해시
```

**특징**:
- 단방향 함수 (역산 불가능)
- 256비트 = 64자리 16진수
- 한 글자만 바뀌어도 완전히 다른 해시

### secrets.compare_digest()

```python
# Timing attack 방어
import secrets

# 항상 모든 문자를 비교 (동일한 시간 소요)
secrets.compare_digest('hello', 'world')  # 0.000001초
secrets.compare_digest('hello', 'hello')  # 0.000001초
```

---

## 테스트 코드 작성

```python
# backend/accounts/tests/test_security.py:271
class EmailVerificationSecurityTest(TestCase):
    def test_token_is_hashed(self):
        """토큰이 평문으로 저장되지 않는지 확인"""
        user = User.objects.create_user(email='test@example.com')
        token = user.generate_email_verification_token()

        user.refresh_from_db()

        # 1. 평문과 다르게 저장되어야 함
        self.assertNotEqual(user.email_verification_token, token)

        # 2. SHA-256 해시 길이 (64자)
        self.assertEqual(len(user.email_verification_token), 64)

    def test_verification_success(self):
        """올바른 토큰으로 검증 성공"""
        user = User.objects.create_user(email='test@example.com')
        token = user.generate_email_verification_token()

        # 검증 성공
        self.assertTrue(user.verify_email(token))

        # 토큰 삭제 확인
        user.refresh_from_db()
        self.assertIsNone(user.email_verification_token)
```

---

## 보안 개선 효과

### Before
```
저장 방식: 평문
비교 방식: == 연산자
만료 시간: 없음
재사용: 가능
위험도: HIGH
```

### After
```
저장 방식: SHA-256 해시
비교 방식: secrets.compare_digest()
만료 시간: 1일
재사용: 불가 (일회용)
위험도: LOW
```

---

## 배운 점

### 1. 민감한 데이터는 절대 평문 저장 금지

비밀번호만 해싱하는게 아니다. **계정 제어권**을 가진 모든 토큰을 해싱해야 한다.

### 2. Python secrets 모듈은 보안의 기본

```python
# 토큰 생성: secrets 모듈
# 토큰 비교: secrets.compare_digest()
```

이 두 개는 암기.

### 3. Timing Attack은 실제 위협

"이론상 가능하다"가 아니라 "실제로 해킹당한다".
Constant-time 비교는 선택이 아니라 필수다.

### 4. 일회용 토큰의 중요성

```python
# 검증 성공 후
self.email_verification_token = None  # 토큰 삭제
```

토큰 재사용을 막는 것도 중요한 보안 조치다.

---

## 체크리스트

인증 토큰 구현 시:

- [ ] `secrets.token_urlsafe()`로 생성
- [ ] SHA-256으로 해싱 후 저장
- [ ] `secrets.compare_digest()`로 비교
- [ ] 만료 시간 설정 (1일 권장)
- [ ] 일회용 토큰 (사용 후 삭제)
- [ ] 테스트 코드 작성
- [ ] HTTPS 필수 (프로덕션)

---

## 관련 코드

- 토큰 생성: `backend/accounts/models.py:107`
- 토큰 검증: `backend/accounts/models.py:125`
- 테스트: `backend/accounts/tests/test_security.py:271`
- 커밋: `18e9bcf`

---

## 참고한 자료

- [Python secrets 모듈](https://docs.python.org/3/library/secrets.html)
- [hashlib 문서](https://docs.python.org/3/library/hashlib.html)
- [OWASP: Timing Attack](https://owasp.org/www-community/attacks/Timing_attack)

---

## 정리

보안은 "나중에 하면 안 되는 것"이다.
초기부터 제대로 설계하지 않으면, 나중에 고치기가 훨씬 어렵다.

이번 리팩토링은 반나절 걸렸지만, 처음부터 이렇게 했으면 1시간이면 충분했을 것이다.

**다음 프로젝트에서 적용할 점**:
- 인증 관련 코드 짤 때 이 문서 다시 읽기
- secrets 모듈 기본으로 쓰기
- 보안 테스트 코드 먼저 작성하기
