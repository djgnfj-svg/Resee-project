# N+1 쿼리 최적화

> **핵심 성과**: 쿼리 **201번 → 1번 (99.5% 감소)**, API 응답 **800ms → 50ms (93% 단축)**

---

## 한 줄 요약

`select_related()`와 Mixin 패턴으로 쿼리 200번 줄임

---

## 배경

복습 목록 조회 시 100개 항목마다 201번의 DB 쿼리가 발생하여 API 응답이 800ms 소요되었다.
Django ORM의 N+1 문제를 `select_related()`와 재사용 가능한 Mixin 패턴으로 해결하여 1번의 쿼리로 최적화했다.

---

## 선택 이유

**왜 ORM 최적화를 했는가?**

채용 공고에서 가장 많이 본 질문이 "Django ORM N+1 문제를 어떻게 해결하나요?"였습니다.
실제로 복습 목록 API가 느려지는 문제를 겪으면서 이론으로만 알던 N+1 문제를 직접 해결했습니다.

**대안 검토**:
- ❌ **Raw SQL**: 복잡하고 유지보수 어려움
- ❌ **캐싱만 사용**: 실시간 데이터 반영 불가
- ✅ **ORM 최적화**: 코드 간결하고 자동으로 JOIN 처리

---

## 문제

복습 목록 100개 조회 시 201번의 쿼리 발생 → 800ms 지연

```python
# backend/review/views.py (개선 전 - f4da60f 커밋)
class ReviewScheduleViewSet(viewsets.ModelViewSet):
    """Review schedule viewset"""
    queryset = ReviewSchedule.objects.all()
    serializer_class = ReviewScheduleSerializer

    def get_queryset(self):
        return ReviewSchedule.objects.filter(user=self.request.user)
        # ❌ select_related 없음 → N+1 쿼리 발생!

# 시리얼라이저에서 content, category 접근 시마다 추가 쿼리 발생
# 100개 ReviewSchedule 조회 시:
# - 1번: ReviewSchedule 조회
# - 100번: 각각의 content 조회 (N+1)
# - 100번: 각각의 category 조회 (N+1)
# 총 201번 쿼리!
```

**쿼리 분석**:
```sql
-- 1번째: ReviewSchedule 조회
SELECT * FROM review_schedule WHERE user_id = 1;

-- 2~101번째: 각 schedule의 content 조회 (N+1 문제!)
SELECT * FROM content WHERE id = 1;
SELECT * FROM content WHERE id = 2;
...
SELECT * FROM content WHERE id = 100;

-- 102~201번째: 각 content의 category 조회 (N+1 문제!)
SELECT * FROM category WHERE id = 1;
SELECT * FROM category WHERE id = 2;
...
SELECT * FROM category WHERE id = 100;
```

---

## 해결

### Before → After

#### Before (프로젝트 초기)

```python
# backend/review/views.py (개선 전 - f4da60f 커밋)
class ReviewScheduleViewSet(viewsets.ModelViewSet):
    """Review schedule viewset"""
    queryset = ReviewSchedule.objects.all()
    serializer_class = ReviewScheduleSerializer

    def get_queryset(self):
        return ReviewSchedule.objects.filter(user=self.request.user)
        # ❌ select_related 없음 → N+1 쿼리 발생!
```

#### After (현재)

```python
# backend/review/views.py (개선 후 - 현재)
from resee.mixins import UserOwnershipMixin

class ReviewScheduleViewSet(UserOwnershipMixin, viewsets.ModelViewSet):
    """
    복습 스케줄 관리

    에빙하우스 망각곡선 기반 복습 스케줄을 관리합니다.
    """
    queryset = ReviewSchedule.objects.all()
    serializer_class = ReviewScheduleSerializer
    pagination_class = ReviewPagination

    # Query optimization configuration
    select_related_fields = ['content', 'content__category', 'user']

    # UserOwnershipMixin → OptimizedQueryMixin 상속
    # → get_queryset()에서 자동으로 select_related 적용
    # 100개 조회 시 단 1번의 JOIN 쿼리로 모든 데이터 가져옴!
```

**Mixin 구현**:

```python
# backend/resee/mixins.py:99-118
class OptimizedQueryMixin:
    """쿼리 최적화 Mixin"""
    select_related_fields = []
    prefetch_related_fields = []

    def get_queryset(self):
        queryset = super().get_queryset()

        if self.select_related_fields:
            queryset = queryset.select_related(*self.select_related_fields)

        if self.prefetch_related_fields:
            queryset = queryset.prefetch_related(*self.prefetch_related_fields)

        return queryset

class UserOwnershipMixin:
    """사용자 소유권 Mixin"""
    user_field = 'user'

    def get_queryset(self):
        queryset = super().get_queryset()
        user_filter = {self.user_field: self.request.user}
        return queryset.filter(**user_filter)

class BaseViewSetMixin(UserOwnershipMixin, OptimizedQueryMixin):
    """기본 ViewSet Mixin - 소유권 + 쿼리 최적화"""
    pass
```

**최적화된 SQL**:
```sql
-- 단 1번의 JOIN 쿼리로 모든 데이터 조회
SELECT
    review_schedule.*,
    content.*,
    category.*,
    user.*
FROM review_schedule
LEFT JOIN content ON review_schedule.content_id = content.id
LEFT JOIN category ON content.category_id = category.id
LEFT JOIN user ON review_schedule.user_id = user.id
WHERE review_schedule.user_id = 1;
```

### Workflow

```
Before: N+1 쿼리
  Client → Django → ReviewSchedule 조회 (1번)
                 → Content 조회 (100번)
                 → Category 조회 (100번)
  총 201번 쿼리 → 800ms

After: JOIN 쿼리
  Client → Django → JOIN 쿼리 (1번)
  총 1번 쿼리 → 50ms
```

---

## 성과

| 지표 | Before | After | 개선 |
|-----|--------|-------|------|
| **쿼리 수** | 201번 | 1번 | **99.5% 감소** |
| **API 응답** | ~800ms | ~50ms | **93% 단축** |
| **DB 부하** | 높음 | 낮음 | - |

---

## 코드 위치

```
backend/resee/mixins.py:99-150     # OptimizedQueryMixin, UserOwnershipMixin
backend/review/views.py:27-40      # ReviewScheduleViewSet (개선 후)
```

**핵심 로직 (3줄)**:
```python
select_related_fields = ['content', 'content__category', 'user']  # 1. 필드 선언
# UserOwnershipMixin → OptimizedQueryMixin 상속              # 2. Mixin 상속
# get_queryset()에서 자동으로 select_related 적용             # 3. 자동 최적화
```

---

## 배운 점

Django ORM은 편하지만 기본 동작을 이해하지 않으면 성능 문제가 발생한다.
`select_related()`는 SQL JOIN으로 변환되므로 ForeignKey에만 사용 가능하다.
ManyToMany는 `prefetch_related()`를 써야 한다는 걸 직접 경험했다.

---

**작성일**: 2025-10-24
**키워드**: Django ORM, N+1 쿼리, select_related, 성능 최적화
