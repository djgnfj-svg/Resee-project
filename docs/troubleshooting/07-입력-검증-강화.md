# 입력 검증 강화 회고

> 2025년 10월, DoS 공격 방지와 데이터 무결성 보장

## 개요

- **문제 발견**: 2025년 10월
- **해결 완료**: 같은 날 (1시간 소요)
- **원인**: API 입력값 검증이 부족해서 보안 취약점과 데이터 무결성 문제 발생 가능

---

## 문제 발견

복습 완료 API(`CompleteReviewView`)를 리뷰하다가 입력값 검증이 거의 없다는 것을 발견했다.

```python
# backend/review/views.py:207 (수정 전)
def post(self, request):
    content_id = request.data.get('content_id')
    time_spent = request.data.get('time_spent')
    notes = request.data.get('notes', '')
    descriptive_answer = request.data.get('descriptive_answer', '')

    # 검증 없이 바로 사용!
    try:
        schedule = ReviewSchedule.objects.select_for_update().get(
            content_id=content_id,  # 타입 검증 없음
            user=request.user,
            is_active=True
        )
```

**발견된 문제들**:
1. `content_id` - 타입 검증 없음 (문자열이 와도 에러만 터짐)
2. `time_spent` - 음수 가능, 엄청 큰 값 가능
3. `descriptive_answer` - 길이 제한 없음 (DoS 공격 가능)
4. `notes` - 길이 제한 없음

---

## 왜 문제인가?

### 1. DoS 공격 가능

```python
# 공격자가 10MB 텍스트를 보낸다면?
POST /api/review/complete/
{
  "content_id": 1,
  "result": "remembered",
  "descriptive_answer": "a" * 10000000  # 10MB!
}

# 서버에서는
# - 메모리 낭비
# - 데이터베이스에 10MB 저장 시도
# - AI API에 10MB 전송 시도 (실패)
# - 전체 서비스 느려짐
```

**실제 영향**:
- 메모리 부족으로 서버 다운
- 데이터베이스 용량 고갈
- AI API 비용 폭탄

### 2. 데이터 무결성 문제

```python
# time_spent에 음수 입력
{
  "time_spent": -9999
}

# 데이터베이스에 저장됨
# 통계 계산 시 오류:
average_time = sum(time_spent) / count  # 음수 때문에 이상한 값
```

### 3. 타입 에러로 500 에러

```python
# content_id에 문자열 입력
{
  "content_id": "abc"
}

# ReviewSchedule.objects.get(content_id="abc")
# → 타입 불일치로 에러 또는 예상치 못한 동작
```

---

## 원인 분석

### 발견된 입력 검증 누락

| 필드 | 문제 | 보안 위험 | 데이터 위험 |
|------|------|-----------|-------------|
| `content_id` | 타입 검증 없음 | 중간 | 높음 |
| `time_spent` | 범위 검증 없음 | 낮음 | 높음 |
| `notes` | 길이 제한 없음 | **높음** (DoS) | 중간 |
| `descriptive_answer` | 길이 제한 없음 | **높음** (DoS) | 중간 |

### Django의 기본 동작

Django REST Framework는 기본적으로 **입력 검증을 하지 않습니다**:

```python
# 이렇게 받으면
content_id = request.data.get('content_id')

# 모든 값이 가능:
# - None
# - "abc"
# - [1, 2, 3]
# - {"key": "value"}
# - 아무거나!
```

**Serializer를 쓰면**:
```python
# Serializer가 자동으로 검증
class ReviewSerializer(serializers.Serializer):
    content_id = serializers.IntegerField(min_value=1)
    time_spent = serializers.IntegerField(min_value=0, max_value=86400, required=False)
```

하지만 우리는 Serializer를 안 썼으므로 수동 검증이 필요했다.

---

## 해결 과정

### 1단계: content_id 타입 검증

**Before**:
```python
content_id = request.data.get('content_id')
# 바로 사용
schedule = ReviewSchedule.objects.get(content_id=content_id, ...)
```

**After**:
```python
content_id = request.data.get('content_id')

# 필수 값 체크
if not content_id:
    return Response(
        {'error': 'content_id is required'},
        status=status.HTTP_400_BAD_REQUEST
    )

# 타입 검증
try:
    content_id = int(content_id)
except (ValueError, TypeError):
    return Response(
        {'error': 'content_id must be a valid integer'},
        status=status.HTTP_400_BAD_REQUEST
    )
```

**개선 사항**:
- 명시적인 타입 변환
- 변환 실패 시 명확한 에러 메시지
- 400 BAD_REQUEST 반환 (500이 아님)

---

### 2단계: time_spent 범위 검증

**Before**:
```python
time_spent = request.data.get('time_spent')
# 검증 없이 DB 저장
ReviewHistory.objects.create(time_spent=time_spent, ...)
```

**After**:
```python
if time_spent is not None:
    try:
        time_spent = int(time_spent)

        # 음수 체크
        if time_spent < 0:
            return Response(
                {'error': 'time_spent cannot be negative'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 최대값 체크 (24시간 = 86400초)
        if time_spent > 86400:
            return Response(
                {'error': 'time_spent cannot exceed 24 hours (86400 seconds)'},
                status=status.HTTP_400_BAD_REQUEST
            )
    except (ValueError, TypeError):
        return Response(
            {'error': 'time_spent must be a valid integer (seconds)'},
            status=status.HTTP_400_BAD_REQUEST
        )
```

**개선 사항**:
- 음수 방지
- 현실적인 최대값 설정 (24시간)
- optional 필드이므로 None 허용

**왜 24시간?**
- 복습에 24시간 이상 걸릴 리 없음
- 실수로 큰 값 입력 방지
- 통계 계산 시 이상치 제거

---

### 3단계: notes 길이 제한 (DoS 방지)

**Before**:
```python
notes = request.data.get('notes', '')
# 길이 제한 없음
```

**After**:
```python
if notes and len(notes) > 5000:
    return Response(
        {'error': 'notes cannot exceed 5000 characters'},
        status=status.HTTP_400_BAD_REQUEST
    )
```

**5000자를 선택한 이유**:
- 충분히 길다 (A4 용지 2-3장)
- 너무 길지 않다 (메모리/DB 부담 적음)
- DoS 공격 방지

---

### 4단계: descriptive_answer 길이 제한 (DoS 방지)

**Before**:
```python
descriptive_answer = request.data.get('descriptive_answer', '')
# 길이 제한 없음 - AI API에 바로 전송
```

**After**:
```python
if descriptive_answer and len(descriptive_answer) > 10000:
    return Response(
        {'error': 'descriptive_answer cannot exceed 10000 characters'},
        status=status.HTTP_400_BAD_REQUEST
    )
```

**10000자를 선택한 이유**:
- AI 평가용이므로 notes보다 길게
- Anthropic API 토큰 제한 고려
- DoS 공격 방지

**비용 계산**:
```
10000자 = 약 2500 토큰
claude-3-haiku 가격: $0.25 / 1M 토큰
→ 1회당 $0.000625 (0.06원)

길이 제한 없으면?
100MB = 약 2500만 토큰
→ 1회당 $6.25 (6250원)
→ 공격자가 1000번 호출 시 625만원!
```

---

### 5단계: 소유권 검증 개선

**Before**:
```python
schedule = ReviewSchedule.objects.select_for_update().get(
    content_id=content_id,
    user=request.user,
    is_active=True
)
# DoesNotExist 예외는 나중에 catch
```

**After**:
```python
try:
    schedule = ReviewSchedule.objects.select_for_update().get(
        content_id=content_id,
        user=request.user,
        is_active=True
    )
except ReviewSchedule.DoesNotExist:
    logger.warning(
        f"Review schedule not found or access denied: "
        f"user={request.user.email}, content_id={content_id}"
    )
    return Response(
        {'error': 'Review schedule not found or you do not have permission to access it'},
        status=status.HTTP_404_NOT_FOUND
    )
```

**개선 사항**:
- 명시적인 예외 처리
- 로깅으로 의심스러운 접근 추적
- 명확한 에러 메시지

---

## 배운 점

### 1. 방어적 프로그래밍 (Defensive Programming)

```python
# ❌ 낙관적: "사용자가 올바른 값을 보낼 거야"
content_id = request.data.get('content_id')
schedule = ReviewSchedule.objects.get(content_id=content_id)

# ✅ 방어적: "사용자는 뭐든 보낼 수 있어"
content_id = request.data.get('content_id')
if not content_id:
    return error
try:
    content_id = int(content_id)
except ValueError:
    return error
schedule = ReviewSchedule.objects.get(content_id=content_id)
```

**원칙**: "모든 입력은 악의적이라고 가정하라"

### 2. 입력 검증 체크리스트

모든 API 입력에 대해:

- [ ] **타입 검증**: 기대하는 타입인가?
- [ ] **필수 여부**: 필수 필드가 있는가?
- [ ] **범위 검증**: 최소/최대값이 적절한가?
- [ ] **길이 제한**: 문자열/배열 길이가 제한되어 있는가?
- [ ] **포맷 검증**: 이메일, URL 등 포맷이 올바른가?
- [ ] **허용 값**: enum처럼 특정 값만 허용하는가?
- [ ] **소유권 검증**: 리소스에 접근 권한이 있는가?

### 3. DoS 공격 방지 전략

**길이 제한 가이드**:

| 필드 타입 | 권장 최대 길이 | 이유 |
|-----------|---------------|------|
| 사용자명 | 50-100자 | 화면 표시 고려 |
| 이메일 | 254자 | RFC 5321 표준 |
| 비밀번호 | 128자 | bcrypt 제한 |
| 짧은 메모 | 500-1000자 | 트위터 스타일 |
| 긴 메모 | 5000자 | A4 2-3장 |
| 본문 | 10000-50000자 | 용도에 따라 |

**추가 방어 수단**:
- Rate limiting (1분에 10회 등)
- Request body 크기 제한 (Nginx/Django)
- 타임아웃 설정

### 4. Serializer vs 수동 검증

**Serializer 사용 (권장)**:
```python
class ReviewSerializer(serializers.Serializer):
    content_id = serializers.IntegerField(min_value=1)
    time_spent = serializers.IntegerField(
        min_value=0,
        max_value=86400,
        required=False,
        allow_null=True
    )
    notes = serializers.CharField(
        max_length=5000,
        required=False,
        allow_blank=True
    )
```

**장점**:
- 선언적 (읽기 쉬움)
- 재사용 가능
- 자동 문서화 (Swagger)
- 에러 메시지 일관성

**수동 검증 (우리가 한 것)**:
```python
if not content_id:
    return Response(...)
try:
    content_id = int(content_id)
except ValueError:
    return Response(...)
```

**장점**:
- 간단한 경우 더 빠름
- 커스텀 로직 쉬움
- Serializer 없이도 가능

**단점**:
- 코드가 길어짐
- 일관성 유지 어려움
- 재사용 어려움

### 5. 보안 vs 사용성

```python
# 너무 엄격하면?
if len(notes) > 100:  # 너무 짧음
    return error

# 너무 관대하면?
if len(notes) > 1000000:  # DoS 가능
    return error

# 적절한 균형
if len(notes) > 5000:  # 충분히 길지만 안전
    return error
```

**균형점 찾기**:
1. 실제 사용 패턴 분석
2. 99%의 사용자 커버
3. 1%의 남용 차단

---

## 체크리스트

새 API 엔드포인트 작성 시:

**입력 검증**:
- [ ] 모든 필수 필드 검증
- [ ] 타입 검증 (int, str, bool 등)
- [ ] 범위 검증 (min, max)
- [ ] 길이 제한 (문자열, 배열)
- [ ] 포맷 검증 (이메일, URL 등)

**보안**:
- [ ] 소유권 검증 (리소스 접근 권한)
- [ ] Rate limiting 적용
- [ ] DoS 방지 (길이, 크기 제한)
- [ ] SQL Injection 방지 (ORM 사용)
- [ ] XSS 방지 (출력 이스케이프)

**에러 처리**:
- [ ] 명확한 에러 메시지
- [ ] 적절한 HTTP 상태 코드
- [ ] 의심스러운 요청 로깅

---

## 개선 결과

### Before
```python
# 어떤 값이든 받아서 처리
content_id = request.data.get('content_id')
time_spent = request.data.get('time_spent')
notes = request.data.get('notes', '')
descriptive_answer = request.data.get('descriptive_answer', '')

# 바로 DB 저장
schedule = ReviewSchedule.objects.get(content_id=content_id, ...)
```

**문제점**:
- DoS 공격 가능 (무제한 텍스트)
- 타입 에러로 500 에러
- 음수 time_spent 저장
- 데이터 무결성 문제

### After
```python
# === Input Validation ===
# 1. content_id validation (타입, 필수)
# 2. time_spent validation (범위 0-86400)
# 3. notes length validation (최대 5000자)
# 4. descriptive_answer length validation (최대 10000자)

# 검증 통과한 값만 처리
schedule = ReviewSchedule.objects.get(content_id=content_id, ...)
```

**개선 사항**:
- DoS 공격 방지 (길이 제한)
- 명확한 에러 메시지 (400 BAD_REQUEST)
- 데이터 무결성 보장
- 로깅으로 의심스러운 접근 추적

---

## 관련 코드

- 수정한 파일:
  * `backend/review/views.py:207-282` - CompleteReviewView 입력 검증 추가
- 커밋: (다음 단계에서 생성)

---

## 참고한 자료

- [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)
- [Django REST Framework Serializers](https://www.django-rest-framework.org/api-guide/serializers/)
- [OWASP Top 10 - Injection](https://owasp.org/www-project-top-ten/)

---

## 정리

1시간 동안 CompleteReviewView의 입력 검증을 강화했다.

**변경 사항**:
- content_id 타입 검증
- time_spent 범위 검증 (0-86400)
- notes 길이 제한 (5000자)
- descriptive_answer 길이 제한 (10000자)
- 소유권 검증 로깅 추가

**다음에 적용할 점**:
- 새 API는 Serializer 사용 고려
- 입력 검증 체크리스트 확인
- DoS 방지를 항상 염두
- Rate limiting 추가

**신입 개발자를 위한 조언**:
> "API는 인터넷에 노출됩니다.
> 악의적인 사용자, 실수하는 사용자, 버그 있는 클라이언트...
> 모든 입력을 의심하고 검증하세요."

**비용 관점**:
> "길이 제한 하나로 AI API 비용 폭탄을 막았습니다.
> 10분 코딩이 수백만원을 아낄 수 있습니다."
