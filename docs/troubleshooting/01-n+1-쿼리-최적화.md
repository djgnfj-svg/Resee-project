# N+1 쿼리 최적화 회고

> 2025년 10월, API 응답 시간을 10배 개선한 기록

## 개요

- **문제 발견**: 2025년 10월
- **해결 완료**: 2025년 10월
- **성과**: 쿼리 99% 감소 (301개 → 3개), 응답 시간 90% 개선 (500ms → 50ms)

---

## 문제 발견

복습 목록 API를 테스트하던 중, 페이지 로딩이 눈에 띄게 느렸다.
Django Debug Toolbar를 확인하니 **301개의 SQL 쿼리**가 실행되고 있었다.

```python
# backend/review/views.py (초기 버전)
class ReviewScheduleViewSet(viewsets.ModelViewSet):
    queryset = ReviewSchedule.objects.all()

    def list(self, request):
        schedules = ReviewSchedule.objects.filter(user=request.user)
        return Response(serializer.data)
```

100개의 스케줄을 조회하는데 300개 넘는 쿼리가 발생했다.

---

## 원인 분석

문제는 Django ORM의 Lazy Loading 방식에 있었다.

```python
schedules = ReviewSchedule.objects.filter(user=request.user)  # 쿼리 1번

for schedule in schedules:  # 100개 반복
    print(schedule.content.title)      # 쿼리 1번씩 추가 (100번)
    print(schedule.content.category)   # 쿼리 1번씩 추가 (100번)
    print(schedule.user.email)         # 쿼리 1번씩 추가 (100번)

# 총 301개 쿼리
```

각 schedule 객체에 접근할 때마다 관련된 content, category, user를 개별적으로 조회했다.
이게 바로 **N+1 쿼리 문제**였다.

```
1번째 쿼리: ReviewSchedule 100개 조회
2~101번 쿼리: Content 100번 조회
102~201번 쿼리: Category 100번 조회
202~301번 쿼리: User 100번 조회
```

---

## 해결 과정

### 1단계: select_related 적용

먼저 ForeignKey 관계에 `select_related()`를 적용했다.

```python
# 개선 1차
schedules = ReviewSchedule.objects.filter(user=request.user).select_related(
    'content',           # Content JOIN
    'content__category', # Category JOIN
    'user'               # User JOIN
)
```

**결과**: 301개 → 1개 쿼리

실제 실행된 SQL을 보니 깔끔한 JOIN 쿼리 하나였다.

```sql
SELECT
    review_reviewschedule.*,
    content_content.*,
    content_category.*,
    accounts_user.*
FROM review_reviewschedule
INNER JOIN content_content ON review_reviewschedule.content_id = content_content.id
INNER JOIN content_category ON content_content.category_id = content_category.id
INNER JOIN accounts_user ON review_reviewschedule.user_id = accounts_user.id
WHERE review_reviewschedule.user_id = 1;
```

### 2단계: Mixin으로 재사용성 확보

문제는 해결했지만, 다른 ViewSet에서도 똑같은 패턴을 반복해야 했다.
ReviewHistoryViewSet, ContentViewSet 모두 비슷한 최적화가 필요했다.

Mixin 패턴을 적용했다.

```python
# backend/resee/mixins.py:99
class OptimizedQueryMixin:
    """N+1 쿼리를 자동으로 해결하는 Mixin

    나중에 또 쓸 것 같아서 만든 재사용 가능한 패턴.
    """
    select_related_fields = []
    prefetch_related_fields = []

    def get_queryset(self):
        queryset = super().get_queryset()

        if self.select_related_fields:
            queryset = queryset.select_related(*self.select_related_fields)

        if self.prefetch_related_fields:
            queryset = queryset.prefetch_related(*self.prefetch_related_fields)

        return queryset
```

이제 사용하는 쪽에서는 필드 이름만 나열하면 끝이다.

```python
# backend/review/views.py:35
class ReviewScheduleViewSet(UserOwnershipMixin, viewsets.ModelViewSet):
    queryset = ReviewSchedule.objects.all()
    serializer_class = ReviewScheduleSerializer

    # 이 두 줄만 추가
    select_related_fields = ['content', 'content__category', 'user']
    prefetch_related_fields = []
```

선언적이고, 의도가 명확하다.

### 3단계: Celery 백그라운드 작업에도 적용

이메일 알림 발송 Task에서도 같은 문제가 있었다.

```python
# backend/review/tasks.py:61 (개선 후)
@shared_task
def send_daily_reminders_for_hour(hour: int):
    """1000명에게 이메일 보낼 때 3001개 쿼리 방지"""

    schedules = ReviewSchedule.objects.filter(
        next_review_date__date=today,
        user__notification_preference__daily_reminder_time__hour=hour
    ).select_related(
        'user',
        'content',
        'user__notification_preference'
    ).prefetch_related('content__category')

    # 이제 반복문에서 추가 쿼리 없음
    for schedule in schedules:
        send_email(schedule.user.email, schedule.content.title)
```

**결과**: 1000명 기준 3001개 쿼리 → **4개 쿼리**

---

## 성과 측정

### Before (최적화 전)
```
쿼리 수: 301개
응답 시간: 500ms
사용자 체감: 느림
```

### After (최적화 후)
```
쿼리 수: 3개 (99% 감소)
응답 시간: 50ms (90% 개선)
사용자 체감: 즉시 로딩
```

---

## 배운 점

### 1. Django ORM은 똑똑하지만 마법은 아니다

Lazy Loading은 편리하지만, 방심하면 N+1 쿼리 함정에 빠진다.
"이 코드 몇 개 쿼리 날릴까?" 항상 의식하며 코딩해야 한다.

### 2. select_related vs prefetch_related

| 관계 | 사용 메서드 | 이유 |
|------|------------|------|
| ForeignKey | `select_related()` | SQL JOIN으로 한 번에 |
| OneToOne | `select_related()` | SQL JOIN으로 한 번에 |
| ManyToMany | `prefetch_related()` | 별도 쿼리로 IN 절 활용 |
| Reverse FK | `prefetch_related()` | 별도 쿼리로 IN 절 활용 |

"JOIN 가능하면 select_related, 아니면 prefetch_related"로 기억했다.

### 3. Mixin 패턴의 위력

코드 중복을 줄이는 것도 중요하지만, **실수를 줄이는 것**이 더 중요하다.
최적화를 까먹을 수 있지만, Mixin에 넣어두면 자동으로 적용된다.

### 4. 측정 가능한 개선

"최적화했어요"가 아니라 "쿼리 99% 줄였어요"라고 말할 수 있어야 한다.
Django Debug Toolbar 없었으면 문제도 몰랐을 것이다.

---

## 디버깅 도구

### Django Debug Toolbar

```python
# settings/development.py
INSTALLED_APPS += ['debug_toolbar']
MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
```

개발 환경에서 항상 켜두고 있다. SQL 탭 보는게 습관이 됐다.

### 수동 쿼리 카운트

```python
from django.db import connection

initial = len(connection.queries)
# 코드 실행
final = len(connection.queries)
print(f"쿼리 {final - initial}개 실행됨")
```

간단한 테스트 할 때 자주 쓴다.

---

## 체크리스트

ViewSet 만들 때마다 확인:

- [ ] ForeignKey 관계 있으면 `select_related_fields` 추가했나?
- [ ] ManyToMany 관계 있으면 `prefetch_related_fields` 추가했나?
- [ ] OptimizedQueryMixin 상속했나?
- [ ] Debug Toolbar로 쿼리 개수 확인했나?

---

## 관련 코드

- Mixin 구현: `backend/resee/mixins.py:99`
- ViewSet 적용: `backend/review/views.py:35`
- Celery 적용: `backend/review/tasks.py:61`

---

## 참고한 자료

- [Django 공식 문서: select_related](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#select-related)
- [Django 공식 문서: prefetch_related](https://docs.djangoproject.com/en/4.2/ref/models/querysets/#prefetch-related)

---

## 정리

N+1 쿼리는 정말 흔한 문제다. 아마 앞으로도 자주 마주칠 것이다.
이번에 Mixin으로 패턴화해둔 게 앞으로 큰 도움이 될 것이다.

**다음에 적용할 점**: ViewSet 만들면 무조건 Debug Toolbar 먼저 확인
