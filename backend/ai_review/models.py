"""AI Review models for generating and evaluating interactive questions."""
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

from content.models import Content
from resee.models import BaseModel, BaseUserModel
from review.models import ReviewHistory

User = get_user_model()


class AIQuestionType(BaseModel):
    """Types of AI-generated questions."""
    QUESTION_TYPES = [
        ('multiple_choice', 'Multiple Choice'),
        ('fill_blank', 'Fill in the Blank'),
        ('blur_processing', 'Blur Processing'),
    ]
    
    name = models.CharField(
        max_length=50,
        choices=QUESTION_TYPES,
        unique=True,
        help_text="Internal name for the question type"
    )
    display_name = models.CharField(
        max_length=100,
        help_text="Human-readable name for the question type"
    )
    description = models.TextField(
        blank=True,
        help_text="Description of how this question type works"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this question type is available for generation"
    )
    
    class Meta:
        db_table = 'ai_question_types'
        ordering = ['name']
    
    def __str__(self):
        return self.display_name


class AIQuestion(BaseModel):
    """AI-generated questions for content review."""
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='ai_questions',
        help_text="Content this question is based on"
    )
    question_type = models.ForeignKey(
        AIQuestionType,
        on_delete=models.CASCADE,
        related_name='questions',
        help_text="Type of question (multiple choice, short answer, etc.)"
    )
    question_text = models.TextField(
        help_text="The actual question text generated by AI"
    )
    correct_answer = models.TextField(
        help_text="The correct answer or expected response"
    )
    options = models.JSONField(
        null=True,
        blank=True,
        help_text="Multiple choice options (array of strings) or other structured data"
    )
    difficulty = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        default=1,
        help_text="Difficulty level from 1 (easy) to 5 (very hard)"
    )
    explanation = models.TextField(
        blank=True,
        help_text="AI-generated explanation of the correct answer"
    )
    keywords = models.JSONField(
        null=True,
        blank=True,
        help_text="Key concepts or terms this question covers"
    )
    ai_model_used = models.CharField(
        max_length=100,
        blank=True,
        help_text="AI model used to generate this question"
    )
    generation_prompt = models.TextField(
        blank=True,
        help_text="Prompt used to generate this question (for debugging)"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this question is available for review sessions"
    )
    
    class Meta:
        db_table = 'ai_questions'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['content', 'is_active']),
            models.Index(fields=['question_type', 'difficulty']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"{self.content.title} - {self.question_type.display_name}"
    
    def clean(self):
        """Validate the question based on its type"""
        super().clean()
        
        # Validate multiple choice options
        if self.question_type.name == 'multiple_choice':
            self._validate_multiple_choice()
    
    def _validate_multiple_choice(self):
        """Validate multiple choice question format"""
        if not self.options or not isinstance(self.options, list):
            raise ValidationError("객관식 문제는 선택지를 리스트 형태로 제공해야 합니다.")
        if len(self.options) < 2:
            raise ValidationError("객관식 문제는 최소 2개 이상의 선택지가 필요합니다.")
        if self.correct_answer not in self.options:
            raise ValidationError("정답은 선택지 중 하나여야 합니다.")


class AIEvaluation(BaseUserModel):
    """
    AI evaluation of user answers to questions
    """
    question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='evaluations',
        help_text="Question that was answered"
    )
    user_answer = models.TextField(
        help_text="The user's answer to the question"
    )
    ai_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="AI-generated score from 0.0 (incorrect) to 1.0 (perfect)"
    )
    feedback = models.TextField(
        blank=True,
        help_text="AI-generated feedback on the answer"
    )
    similarity_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="Semantic similarity score between user answer and correct answer"
    )
    evaluation_details = models.JSONField(
        null=True,
        blank=True,
        help_text="Detailed evaluation breakdown (reasoning, partial scores, etc.)"
    )
    ai_model_used = models.CharField(
        max_length=100,
        blank=True,
        help_text="AI model used for evaluation"
    )
    processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        help_text="Time taken for AI evaluation in milliseconds"
    )
    
    class Meta:
        db_table = 'ai_evaluations'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['question', 'ai_score']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        question_preview = (self.question.question_text[:30] + "..." 
                          if len(self.question.question_text) > 30 
                          else self.question.question_text)
        return f"{self.user.email} - {question_preview} - {self.ai_score}"


class AIReviewSession(BaseModel):
    """
    AI-enhanced review session tracking
    """
    review_history = models.OneToOneField(
        ReviewHistory,
        on_delete=models.CASCADE,
        related_name='ai_session',
        help_text="Associated traditional review history record"
    )
    questions_generated = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Number of AI questions generated for this session"
    )
    questions_answered = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Number of questions the user answered"
    )
    average_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="Average AI score across all answered questions"
    )
    session_duration_seconds = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0)],
        help_text="Total time spent in the review session"
    )
    ai_processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0)],
        help_text="Total time spent on AI processing during the session"
    )
    session_type = models.CharField(
        max_length=50,
        default='mixed',
        choices=[
            ('traditional', 'Traditional Review'),
            ('ai_only', 'AI Questions Only'),
            ('mixed', 'Mixed Traditional + AI'),
        ],
        help_text="Type of review session"
    )
    notes = models.TextField(
        blank=True,
        help_text="Session notes or observations"
    )
    
    class Meta:
        db_table = 'ai_review_sessions'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['review_history']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        user = self.review_history.user
        content = self.review_history.content
        return f"{user.email} - {content.title} - AI Session"
    
    @property
    def completion_percentage(self):
        """Calculate percentage of questions answered"""
        if self.questions_generated == 0:
            return 0.0
        return (self.questions_answered / self.questions_generated) * 100.0


class WeeklyTest(BaseUserModel):
    """
    주간 종합 시험 모델 - 적응형 난이도 조절 기능 포함
    """
    category = models.ForeignKey(
        'content.Category',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        help_text="선택한 카테고리 (None이면 전체 콘텐츠)"
    )
    week_start_date = models.DateField(
        help_text="주간 시작일 (월요일)"
    )
    week_end_date = models.DateField(
        help_text="주간 종료일 (일요일)"
    )
    total_questions = models.IntegerField(
        default=10,
        validators=[MinValueValidator(5), MaxValueValidator(30)],
        help_text="총 문제 수"
    )
    
    # 적응형 난이도 조절 기능
    adaptive_mode = models.BooleanField(
        default=True,
        help_text="적응형 모드 활성화"
    )
    current_difficulty = models.CharField(
        max_length=20,
        choices=[
            ('easy', '쉬움'),
            ('medium', '보통'), 
            ('hard', '어려움')
        ],
        default='medium',
        help_text="현재 난이도"
    )
    consecutive_correct = models.IntegerField(
        default=0,
        help_text="연속 정답 수"
    )
    consecutive_wrong = models.IntegerField(
        default=0,
        help_text="연속 오답 수"
    )
    
    # 문제 유형별 분배 (객관식 6 + 주관식 3 + 서술형 1)
    question_type_distribution = models.JSONField(
        default=dict,
        help_text="문제 유형별 분배 {'multiple_choice': 6, 'short_answer': 3, 'essay': 1}"
    )
    
    # 추정 숙련도
    estimated_proficiency = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="추정 숙련도 (0-100)"
    )
    completed_questions = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="완료한 문제 수"
    )
    correct_answers = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="정답 수"
    )
    score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="최종 점수 (0-100)"
    )
    time_limit_minutes = models.IntegerField(
        default=30,
        choices=[(30, '30분'), (60, '60분'), (0, '무제한')],
        help_text="시험 시간 제한"
    )
    started_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="시험 시작 시간"
    )
    completed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="시험 완료 시간"
    )
    difficulty_distribution = models.JSONField(
        default=dict,
        help_text="난이도별 문제 분포 {'easy': 5, 'medium': 8, 'hard': 2}"
    )
    content_coverage = models.JSONField(
        default=list,
        help_text="포함된 콘텐츠 ID 목록"
    )
    weak_areas = models.JSONField(
        default=list,
        help_text="취약 분야 분석 결과"
    )
    improvement_from_last_week = models.FloatField(
        null=True,
        blank=True,
        help_text="지난 주 대비 향상도 (%)"
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ('draft', '준비중'),
            ('ready', '시작가능'),
            ('in_progress', '진행중'),
            ('completed', '완료'),
            ('expired', '만료')
        ],
        default='draft',
        help_text="시험 상태"
    )
    
    class Meta:
        db_table = 'ai_weekly_tests'
        ordering = ['-created_at']
        unique_together = ['user', 'category', 'week_start_date']
        indexes = [
            models.Index(fields=['user', 'week_start_date']),
            models.Index(fields=['user', 'category']),
            models.Index(fields=['status', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - Week {self.week_start_date}"
    
    @property
    def accuracy_rate(self):
        """정답률 계산"""
        if self.completed_questions == 0:
            return 0.0
        return (self.correct_answers / self.completed_questions) * 100.0
    
    @property
    def completion_rate(self):
        """완료율 계산"""
        if self.total_questions == 0:
            return 0.0
        return (self.completed_questions / self.total_questions) * 100.0
    
    @property
    def time_spent_minutes(self):
        """소요 시간 계산 (분)"""
        if self.started_at and self.completed_at:
            delta = self.completed_at - self.started_at
            return delta.total_seconds() / 60
        return 0
    
    def is_expired(self):
        """시간 제한 만료 여부 확인"""
        if self.time_limit_minutes == 0:  # 무제한
            return False
        if self.started_at and self.status == 'in_progress':
            from django.utils import timezone
            elapsed = (timezone.now() - self.started_at).total_seconds() / 60
            return elapsed > self.time_limit_minutes
        return False
    
    def adjust_difficulty(self, is_correct):
        """적응형 난이도 조절"""
        if not self.adaptive_mode:
            return
            
        if is_correct:
            self.consecutive_correct += 1
            self.consecutive_wrong = 0
            
            # 연속 2회 정답 시 난이도 상승
            if self.consecutive_correct >= 2:
                if self.current_difficulty == 'easy':
                    self.current_difficulty = 'medium'
                elif self.current_difficulty == 'medium':
                    self.current_difficulty = 'hard'
                self.consecutive_correct = 0
        else:
            self.consecutive_wrong += 1
            self.consecutive_correct = 0
            
            # 연속 2회 오답 시 난이도 하락
            if self.consecutive_wrong >= 2:
                if self.current_difficulty == 'hard':
                    self.current_difficulty = 'medium'
                elif self.current_difficulty == 'medium':
                    self.current_difficulty = 'easy'
                self.consecutive_wrong = 0
        
        self.save(update_fields=['current_difficulty', 'consecutive_correct', 'consecutive_wrong'])
    
    def get_question_type_for_order(self, order):
        """문제 순서에 따른 문제 유형 반환 (객6 + 주3 + 서1)"""
        if order <= 6:
            return 'multiple_choice'
        elif order <= 9:
            return 'short_answer'
        else:
            return 'essay'


class WeeklyTestQuestion(models.Model):
    """
    주간 시험 문제
    """
    weekly_test = models.ForeignKey(
        WeeklyTest,
        on_delete=models.CASCADE,
        related_name='test_questions',
        help_text="소속 주간 시험"
    )
    ai_question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='weekly_test_uses',
        help_text="AI 생성 문제"
    )
    order = models.IntegerField(
        help_text="문제 순서"
    )
    user_answer = models.TextField(
        blank=True,
        help_text="사용자 답변"
    )
    is_correct = models.BooleanField(
        null=True,
        blank=True,
        help_text="정답 여부"
    )
    ai_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="AI 평가 점수"
    )
    time_spent_seconds = models.IntegerField(
        null=True,
        blank=True,
        help_text="문제 풀이 시간 (초)"
    )
    answered_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="답변 제출 시간"
    )
    
    class Meta:
        db_table = 'ai_weekly_test_questions'
        ordering = ['order']
        unique_together = ['weekly_test', 'order']
    
    def __str__(self):
        return f"{self.weekly_test} - Q{self.order}"


class ContentUnderstandingCheck(BaseUserModel):
    """
    콘텐츠 이해도 검사 모델 - 작성 완료 후 AI가 이해도를 체크
    """
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='understanding_checks',
        help_text="검사 대상 콘텐츠"
    )
    questions_count = models.IntegerField(
        default=3,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        help_text="생성된 문제 수"
    )
    correct_count = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="정답 수"
    )
    understanding_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="이해도 점수 (0-100)"
    )
    weak_points = models.JSONField(
        default=list,
        help_text="취약점 목록"
    )
    feedback = models.TextField(
        blank=True,
        help_text="AI 생성 피드백"
    )
    duration_seconds = models.IntegerField(
        help_text="검사 소요 시간 (초)"
    )
    
    class Meta:
        db_table = 'ai_content_understanding_checks'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'content', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - {self.content.title} 이해도 검사"
    
    @property
    def accuracy_rate(self):
        """정답률 계산"""
        if self.questions_count == 0:
            return 0.0
        return (self.correct_count / self.questions_count) * 100.0




