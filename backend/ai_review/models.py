"""AI Review models for generating and evaluating interactive questions."""
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models

from content.models import Content
from resee.models import BaseModel, BaseUserModel
from review.models import ReviewHistory

User = get_user_model()


class AIQuestionType(BaseModel):
    """Types of AI-generated questions."""
    QUESTION_TYPES = [
        ('multiple_choice', 'Multiple Choice'),
        ('fill_blank', 'Fill in the Blank'),
        ('blur_processing', 'Blur Processing'),
    ]
    
    name = models.CharField(
        max_length=50,
        choices=QUESTION_TYPES,
        unique=True,
        help_text="Internal name for the question type"
    )
    display_name = models.CharField(
        max_length=100,
        help_text="Human-readable name for the question type"
    )
    description = models.TextField(
        blank=True,
        help_text="Description of how this question type works"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this question type is available for generation"
    )
    
    class Meta:
        db_table = 'ai_question_types'
        ordering = ['name']
    
    def __str__(self):
        return self.display_name


class AIQuestion(models.Model):
    """AI-generated questions for content review."""
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='ai_questions',
        help_text="Content this question is based on"
    )
    question_type = models.ForeignKey(
        AIQuestionType,
        on_delete=models.CASCADE,
        related_name='questions',
        help_text="Type of question (multiple choice, short answer, etc.)"
    )
    question_text = models.TextField(
        help_text="The actual question text generated by AI"
    )
    correct_answer = models.TextField(
        help_text="The correct answer or expected response"
    )
    options = models.JSONField(
        null=True,
        blank=True,
        help_text="Multiple choice options (array of strings) or other structured data"
    )
    difficulty = models.IntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        default=1,
        help_text="Difficulty level from 1 (easy) to 5 (very hard)"
    )
    explanation = models.TextField(
        blank=True,
        help_text="AI-generated explanation of the correct answer"
    )
    keywords = models.JSONField(
        null=True,
        blank=True,
        help_text="Key concepts or terms this question covers"
    )
    ai_model_used = models.CharField(
        max_length=100,
        blank=True,
        help_text="AI model used to generate this question"
    )
    generation_prompt = models.TextField(
        blank=True,
        help_text="Prompt used to generate this question (for debugging)"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this question is available for review sessions"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'ai_questions'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['content', 'is_active']),
            models.Index(fields=['question_type', 'difficulty']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"{self.content.title} - {self.question_type.display_name}"
    
    def clean(self):
        """Validate the question based on its type"""
        super().clean()
        
        # Validate multiple choice options
        if self.question_type.name == 'multiple_choice':
            self._validate_multiple_choice()
    
    def _validate_multiple_choice(self):
        """Validate multiple choice question format"""
        if not self.options or not isinstance(self.options, list):
            raise ValidationError("객관식 문제는 선택지를 리스트 형태로 제공해야 합니다.")
        if len(self.options) < 2:
            raise ValidationError("객관식 문제는 최소 2개 이상의 선택지가 필요합니다.")
        if self.correct_answer not in self.options:
            raise ValidationError("정답은 선택지 중 하나여야 합니다.")


class AIEvaluation(models.Model):
    """
    AI evaluation of user answers to questions
    """
    question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='evaluations',
        help_text="Question that was answered"
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='ai_evaluations',
        help_text="User who answered the question"
    )
    user_answer = models.TextField(
        help_text="The user's answer to the question"
    )
    ai_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="AI-generated score from 0.0 (incorrect) to 1.0 (perfect)"
    )
    feedback = models.TextField(
        blank=True,
        help_text="AI-generated feedback on the answer"
    )
    similarity_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="Semantic similarity score between user answer and correct answer"
    )
    evaluation_details = models.JSONField(
        null=True,
        blank=True,
        help_text="Detailed evaluation breakdown (reasoning, partial scores, etc.)"
    )
    ai_model_used = models.CharField(
        max_length=100,
        blank=True,
        help_text="AI model used for evaluation"
    )
    processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        help_text="Time taken for AI evaluation in milliseconds"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'ai_evaluations'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['question', 'ai_score']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        question_preview = (self.question.question_text[:30] + "..." 
                          if len(self.question.question_text) > 30 
                          else self.question.question_text)
        return f"{self.user.email} - {question_preview} - {self.ai_score}"


class AIReviewSession(models.Model):
    """
    AI-enhanced review session tracking
    """
    review_history = models.OneToOneField(
        ReviewHistory,
        on_delete=models.CASCADE,
        related_name='ai_session',
        help_text="Associated traditional review history record"
    )
    questions_generated = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Number of AI questions generated for this session"
    )
    questions_answered = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Number of questions the user answered"
    )
    average_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="Average AI score across all answered questions"
    )
    session_duration_seconds = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0)],
        help_text="Total time spent in the review session"
    )
    ai_processing_time_ms = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0)],
        help_text="Total time spent on AI processing during the session"
    )
    session_type = models.CharField(
        max_length=50,
        default='mixed',
        choices=[
            ('traditional', 'Traditional Review'),
            ('ai_only', 'AI Questions Only'),
            ('mixed', 'Mixed Traditional + AI'),
        ],
        help_text="Type of review session"
    )
    notes = models.TextField(
        blank=True,
        help_text="Session notes or observations"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'ai_review_sessions'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['review_history']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        user = self.review_history.user
        content = self.review_history.content
        return f"{user.email} - {content.title} - AI Session"
    
    @property
    def completion_percentage(self):
        """Calculate percentage of questions answered"""
        if self.questions_generated == 0:
            return 0.0
        return (self.questions_answered / self.questions_generated) * 100.0


class WeeklyTest(models.Model):
    """
    주간 종합 시험 모델 - 적응형 난이도 조절 기능 포함
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='weekly_tests',
        help_text="시험을 본 사용자"
    )
    category = models.ForeignKey(
        'content.Category',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        help_text="선택한 카테고리 (None이면 전체 콘텐츠)"
    )
    week_start_date = models.DateField(
        help_text="주간 시작일 (월요일)"
    )
    week_end_date = models.DateField(
        help_text="주간 종료일 (일요일)"
    )
    total_questions = models.IntegerField(
        default=10,
        validators=[MinValueValidator(5), MaxValueValidator(30)],
        help_text="총 문제 수"
    )
    
    # 적응형 난이도 조절 기능
    adaptive_mode = models.BooleanField(
        default=True,
        help_text="적응형 모드 활성화"
    )
    current_difficulty = models.CharField(
        max_length=20,
        choices=[
            ('easy', '쉬움'),
            ('medium', '보통'), 
            ('hard', '어려움')
        ],
        default='medium',
        help_text="현재 난이도"
    )
    consecutive_correct = models.IntegerField(
        default=0,
        help_text="연속 정답 수"
    )
    consecutive_wrong = models.IntegerField(
        default=0,
        help_text="연속 오답 수"
    )
    
    # 문제 유형별 분배 (객관식 6 + 주관식 3 + 서술형 1)
    question_type_distribution = models.JSONField(
        default=dict,
        help_text="문제 유형별 분배 {'multiple_choice': 6, 'short_answer': 3, 'essay': 1}"
    )
    
    # 추정 숙련도
    estimated_proficiency = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="추정 숙련도 (0-100)"
    )
    completed_questions = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="완료한 문제 수"
    )
    correct_answers = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="정답 수"
    )
    score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="최종 점수 (0-100)"
    )
    time_limit_minutes = models.IntegerField(
        default=30,
        choices=[(30, '30분'), (60, '60분'), (0, '무제한')],
        help_text="시험 시간 제한"
    )
    started_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="시험 시작 시간"
    )
    completed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="시험 완료 시간"
    )
    difficulty_distribution = models.JSONField(
        default=dict,
        help_text="난이도별 문제 분포 {'easy': 5, 'medium': 8, 'hard': 2}"
    )
    content_coverage = models.JSONField(
        default=list,
        help_text="포함된 콘텐츠 ID 목록"
    )
    weak_areas = models.JSONField(
        default=list,
        help_text="취약 분야 분석 결과"
    )
    improvement_from_last_week = models.FloatField(
        null=True,
        blank=True,
        help_text="지난 주 대비 향상도 (%)"
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ('draft', '준비중'),
            ('ready', '시작가능'),
            ('in_progress', '진행중'),
            ('completed', '완료'),
            ('expired', '만료')
        ],
        default='draft',
        help_text="시험 상태"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'ai_weekly_tests'
        ordering = ['-created_at']
        unique_together = ['user', 'category', 'week_start_date']
        indexes = [
            models.Index(fields=['user', 'week_start_date']),
            models.Index(fields=['user', 'category']),
            models.Index(fields=['status', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - Week {self.week_start_date}"
    
    @property
    def accuracy_rate(self):
        """정답률 계산"""
        if self.completed_questions == 0:
            return 0.0
        return (self.correct_answers / self.completed_questions) * 100.0
    
    @property
    def completion_rate(self):
        """완료율 계산"""
        if self.total_questions == 0:
            return 0.0
        return (self.completed_questions / self.total_questions) * 100.0
    
    @property
    def time_spent_minutes(self):
        """소요 시간 계산 (분)"""
        if self.started_at and self.completed_at:
            delta = self.completed_at - self.started_at
            return delta.total_seconds() / 60
        return 0
    
    def is_expired(self):
        """시간 제한 만료 여부 확인"""
        if self.time_limit_minutes == 0:  # 무제한
            return False
        if self.started_at and self.status == 'in_progress':
            from django.utils import timezone
            elapsed = (timezone.now() - self.started_at).total_seconds() / 60
            return elapsed > self.time_limit_minutes
        return False
    
    def adjust_difficulty(self, is_correct):
        """적응형 난이도 조절"""
        if not self.adaptive_mode:
            return
            
        if is_correct:
            self.consecutive_correct += 1
            self.consecutive_wrong = 0
            
            # 연속 2회 정답 시 난이도 상승
            if self.consecutive_correct >= 2:
                if self.current_difficulty == 'easy':
                    self.current_difficulty = 'medium'
                elif self.current_difficulty == 'medium':
                    self.current_difficulty = 'hard'
                self.consecutive_correct = 0
        else:
            self.consecutive_wrong += 1
            self.consecutive_correct = 0
            
            # 연속 2회 오답 시 난이도 하락
            if self.consecutive_wrong >= 2:
                if self.current_difficulty == 'hard':
                    self.current_difficulty = 'medium'
                elif self.current_difficulty == 'medium':
                    self.current_difficulty = 'easy'
                self.consecutive_wrong = 0
        
        self.save(update_fields=['current_difficulty', 'consecutive_correct', 'consecutive_wrong'])
    
    def get_question_type_for_order(self, order):
        """문제 순서에 따른 문제 유형 반환 (객6 + 주3 + 서1)"""
        if order <= 6:
            return 'multiple_choice'
        elif order <= 9:
            return 'short_answer'
        else:
            return 'essay'


class WeeklyTestQuestion(models.Model):
    """
    주간 시험 문제
    """
    weekly_test = models.ForeignKey(
        WeeklyTest,
        on_delete=models.CASCADE,
        related_name='test_questions',
        help_text="소속 주간 시험"
    )
    ai_question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='weekly_test_uses',
        help_text="AI 생성 문제"
    )
    order = models.IntegerField(
        help_text="문제 순서"
    )
    user_answer = models.TextField(
        blank=True,
        help_text="사용자 답변"
    )
    is_correct = models.BooleanField(
        null=True,
        blank=True,
        help_text="정답 여부"
    )
    ai_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
        help_text="AI 평가 점수"
    )
    time_spent_seconds = models.IntegerField(
        null=True,
        blank=True,
        help_text="문제 풀이 시간 (초)"
    )
    answered_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="답변 제출 시간"
    )
    
    class Meta:
        db_table = 'ai_weekly_test_questions'
        ordering = ['order']
        unique_together = ['weekly_test', 'order']
    
    def __str__(self):
        return f"{self.weekly_test} - Q{self.order}"


class InstantContentCheck(models.Model):
    """
    실시간 내용 검토 모델
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='instant_checks',
        help_text="검토를 수행한 사용자"
    )
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='instant_checks',
        help_text="검토 대상 콘텐츠"
    )
    check_point = models.CharField(
        max_length=50,
        help_text="검토 시점 (예: 50%, 완료 등)"
    )
    questions_count = models.IntegerField(
        default=3,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        help_text="생성된 문제 수"
    )
    correct_count = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="정답 수"
    )
    understanding_score = models.FloatField(
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="이해도 점수 (0-100)"
    )
    weak_points = models.JSONField(
        default=list,
        help_text="취약점 목록"
    )
    feedback = models.TextField(
        blank=True,
        help_text="AI 생성 피드백"
    )
    duration_seconds = models.IntegerField(
        help_text="검토 소요 시간 (초)"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'ai_instant_content_checks'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'content', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - {self.content.title} @ {self.check_point}"


class AIStudyMate(models.Model):
    """
    AI 스터디 메이트 세션 모델
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='study_mate_sessions',
        help_text="학습자"
    )
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='study_mate_sessions',
        help_text="학습 콘텐츠"
    )
    session_type = models.CharField(
        max_length=30,
        choices=[
            ('guided_learning', '가이드 학습'),
            ('hint_system', '힌트 시스템'),
            ('error_analysis', '오답 분석'),
            ('concept_explanation', '개념 설명')
        ],
        help_text="세션 유형"
    )
    interaction_count = models.IntegerField(
        default=0,
        help_text="상호작용 횟수"
    )
    hints_provided = models.JSONField(
        default=list,
        help_text="제공된 힌트 목록"
    )
    user_level = models.CharField(
        max_length=20,
        choices=[
            ('beginner', '초급'),
            ('intermediate', '중급'),
            ('advanced', '고급')
        ],
        default='intermediate',
        help_text="감지된 사용자 수준"
    )
    adapted_explanations = models.JSONField(
        default=list,
        help_text="수준별 맞춤 설명"
    )
    learning_progress = models.JSONField(
        default=dict,
        help_text="학습 진행 상황 추적"
    )
    session_duration_minutes = models.IntegerField(
        default=0,
        help_text="세션 지속 시간 (분)"
    )
    effectiveness_score = models.FloatField(
        null=True,
        blank=True,
        validators=[MinValueValidator(0.0), MaxValueValidator(100.0)],
        help_text="세션 효과성 점수"
    )
    started_at = models.DateTimeField(
        auto_now_add=True,
        help_text="세션 시작 시간"
    )
    ended_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="세션 종료 시간"
    )
    
    class Meta:
        db_table = 'ai_study_mate_sessions'
        ordering = ['-started_at']
        indexes = [
            models.Index(fields=['user', 'content', 'started_at']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - {self.session_type} ({self.started_at})"


class AISummaryNote(models.Model):
    """
    AI 생성 요약 노트 모델
    """
    content = models.ForeignKey(
        Content,
        on_delete=models.CASCADE,
        related_name='ai_summaries',
        help_text="원본 콘텐츠"
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='ai_summaries',
        help_text="요청한 사용자"
    )
    summary_type = models.CharField(
        max_length=30,
        choices=[
            ('one_page', '1페이지 요약'),
            ('mind_map', '마인드맵'),
            ('key_points', '핵심 포인트'),
            ('cornell_notes', '코넬 노트')
        ],
        default='one_page',
        help_text="요약 형식"
    )
    summary_content = models.TextField(
        help_text="요약 내용"
    )
    key_concepts = models.JSONField(
        default=list,
        help_text="핵심 개념 목록"
    )
    important_terms = models.JSONField(
        default=list,
        help_text="중요 용어 및 정의"
    )
    visual_elements = models.JSONField(
        default=dict,
        help_text="시각적 요소 (다이어그램, 차트 등)"
    )
    study_questions = models.JSONField(
        default=list,
        help_text="학습 확인 질문"
    )
    pdf_url = models.URLField(
        blank=True,
        help_text="생성된 PDF 파일 URL"
    )
    word_count = models.IntegerField(
        default=0,
        help_text="요약 단어 수"
    )
    compression_ratio = models.FloatField(
        default=0.0,
        help_text="압축률 (원본 대비 요약 비율)"
    )
    ai_model_used = models.CharField(
        max_length=100,
        blank=True,
        help_text="사용된 AI 모델"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'ai_summary_notes'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['content', 'user', 'created_at']),
            models.Index(fields=['summary_type', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.content.title} - {self.summary_type} ({self.user.email})"


class AIWrongAnswerClinic(models.Model):
    """
    AI 오답 클리닉 - 틀린 문제에 대한 맞춤형 해설
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='wrong_answer_clinics',
        help_text="질문한 사용자"
    )
    original_question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='clinic_sessions',
        help_text="원본 문제"
    )
    user_answer = models.TextField(
        help_text="사용자의 오답"
    )
    correct_answer = models.TextField(
        help_text="정답"
    )
    
    # AI 분석 결과
    error_analysis = models.TextField(
        help_text="오답 원인 분석"
    )
    concept_explanation = models.TextField(
        help_text="핵심 개념 재설명"
    )
    additional_tips = models.JSONField(
        default=list,
        help_text="추가 학습 팁"
    )
    practice_question = models.JSONField(
        null=True,
        blank=True,
        help_text="연습 문제"
    )
    
    # 메타 정보
    improvement_score = models.FloatField(
        null=True,
        blank=True,
        help_text="재시도 후 향상도"
    )
    is_resolved = models.BooleanField(
        default=False,
        help_text="문제 해결 여부"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'ai_wrong_answer_clinics'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'created_at']),
            models.Index(fields=['original_question', 'is_resolved']),
        ]
    
    def __str__(self):
        return f"{self.user.email} - {self.original_question.question_text[:50]}..."



class AIQuestionTransformer(models.Model):
    """
    AI 문제 변형기 - 같은 개념을 다양하게 묻기
    """
    original_question = models.ForeignKey(
        AIQuestion,
        on_delete=models.CASCADE,
        related_name='transformations',
        help_text="원본 문제"
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='question_transformations',
        help_text="변형을 요청한 사용자"
    )
    
    transformation_type = models.CharField(
        max_length=30,
        choices=[
            ('reverse', '역질문'),
            ('practical', '실생활 적용'),
            ('comparison', '비교형'),
            ('troubleshoot', '문제해결형'),
            ('analogy', '비유/예시'),
            ('step_by_step', '단계별 풀이')
        ],
        help_text="변형 방식"
    )
    
    transformed_question_text = models.TextField(
        help_text="변형된 문제"
    )
    transformed_answer = models.TextField(
        help_text="변형 문제 답안"
    )
    transformation_explanation = models.TextField(
        blank=True,
        help_text="변형 의도 설명"
    )
    
    # 사용자 피드백
    user_rating = models.IntegerField(
        null=True,
        blank=True,
        choices=[(i, f"{i}점") for i in range(1, 6)],
        help_text="사용자 평점 (1-5)"
    )
    is_helpful = models.BooleanField(
        null=True,
        blank=True,
        help_text="도움되었는지 여부"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'ai_question_transformers'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'transformation_type']),
            models.Index(fields=['original_question', 'created_at']),
        ]
    
    def __str__(self):
        return f"{self.original_question.question_text[:30]}... → {self.transformation_type}"
